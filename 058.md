HE1M

medium

# A malicious proposer can prevent finalizing the unproven withdrawal transactions

## Summary

A malicious proposer inserts a withdrawal transaction in two different L2 block numbers that will be proposed in two different `l2Outputs` indices. The first `l2Outputs` is valid, but the second one is invalid. Then, the malicious proposer immediately proves the withdrawal transaction with the index of the second `l2Outputs`. Later, the second `l2Outputs` will be challenged and deleted. Now, the withdrawal transaction is in the first `l2Outputs`, but proved by second `l2Outputs` (with incorrect `outputRoot`). So, the withdrawal can not be proved again, therefore can not be finalized.

## Vulnerability Detail

For simplicity assume that:
 - length of the array `l2Outputs` is 100, so there are already the `l2Outputs` indices 0 to 99.
 https://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/L1/L2OutputOracle.sol#L50
 - `startingBlockNumber` is 1000.
 - https://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/L1/L2OutputOracle.sol#L40
 - `SUBMISSION_INTERVAL` is 120. It means that `l2Outputs[0].l2BlockNumber` is equal to `1120` (1000 + 120), and for the last index we have `l2Outputs[99].l2BlockNumber` equal to `13000` (1000 + 100*120)
 - https://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/L1/L2OutputOracle.sol#L20

Suppose Alice (an innocent user with a large amount of fund) sends a withdrawal message to `L2ToL1MessagePasser` on L2 to receive her fund on L1.

Alice's withdrawal transaction is supposed (it is correct) to be inserted into block number `13100` by the proposer. But, since the proposer is a malicious actor (called Bob) inserts Alice's withdrawal transaction into L2 block number `13200` as well as `13100`. Please note that `latestBlockNumber` is now 13000 and there are now 100 `l2Outputs`. So blocks `13001` to `13120` will be inserted into `l2Outputs` with index 100, and blocks `13121` to `13240` will be inserted into `l2Outputs` with index 101. Therefore, since Alice's withdrawal transaction is included in both blocks `13100` and `13200`, it will be included in both `l2Outputs` 100 and 101. 

Bob generates correct `_outputRoot` and calls the function `proposeL2Output` to propose the `l2Output` with block number 13120 with following parameters:
 - `_outputRoot` = correct data
 - `_l2BlockNumber` = 13120
 - `_l1BlockHash` = not important for this scenario
 -  `_l1BlockNumber` = not important for this scenario
https://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/L1/L2OutputOracle.sol#L160

So, `l2Outputs[100].l2BlockNumber` is 13120 with valid `outputRoot`. Since, the `outputRoot` is generated correctly (without any malicious action), `l2Outputs` with index 100 is a correct output and will not be challenged.

Then Bob generates fake `_outputRoot` and calls the `proposeL2Output` to propose the l2Output with block number 13240 with following parameters:
 - `_outputRoot` = fake data
 - `_l2BlockNumber` = 13240 
 - `_l1BlockHash` = not important for this scenario
 -  `_l1BlockNumber` = not important for this scenario
 
So, `l2Outputs[101].l2BlockNumber` is 13240 with invalid `outputRoot`. Since the `outputRoot` is not correct, it will be challenged later by the `Challenger`.

Then Bob calls the function `proveWithdrawalTransaction` to prove Alice's withdrawal transaction with the following parameters:
 - `_tx` = Alice's withdrawal transaction
 - `_l2OutputIndex` = **101** Please note that Bob is giving the number 101 as index of `l2Outputs` not 100
 - `_outputRootProof` = fake data 
 - `_withdrawalProof` = fake data
https://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/L1/OptimismPortal.sol#L160

Please note that Bob created the fake data as follows:
 - `storageKey` (this is generated from the `withdrawalHash`) is a data that Bob can not manipulate. 
 - So, Bob gives a fake `_withdrawalProof`. This fake `_withdrawalProof` along with the `storageKey` gives an arbitrary root. Bob uses this root as a fake `messagePasserStorageRoot`.
 - Bob puts this fake `messagePasserStorageRoot` beside other arbitrary data `version`, `stateRoot`, and `latestBlockhash`.
 - https://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/libraries/Types.sol#L33
 - Bob uses this structure as `_outputRootProof` and `_withdrawalProof` as parameters during proving the withdrawal transaction.
 - https://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/L1/OptimismPortal.sol#L163
 - Bob gets a hash from this structure `_outputRootProof` to calculate a fake `outputRoot`. 
 - Bob uses this calculated fake `outputRoot` to propose the `l2Outputs` with index 101. So, `l2Outputs` with index 101, has this fake `outputRoot` generated through the above mentioned steps.


Since the proposed `l2Output` with index 101 has fake `outputRoot` (it is generated by Bob), so the following check can be passed easily:
https://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/L1/OptimismPortal.sol#L180

Since this withdrawal transaction is the first time to be proved, its timestamp is equal to zero:
https://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/L1/OptimismPortal.sol#L195

Since `messagePasserStorageRoot` is part of the struct `_outputRootProof ` (this is also generated by Bob), and also the `_withdrawalProof` is provided by Bob, the following check will be easily passed:
https://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/L1/OptimismPortal.sol#L215


Finally the mapping `provenWithdrawals[Alice's withdrawalHash]` will be updated as follows:
 - `outputRoot` = fake value proposed by Bob
 - `timestamp` = current timestamp
 - `l2OutputIndex` = **101**

So far, Alice's withdrawal transaction is included in both `l2Outputs` 100 and 101, and it is proved with `l2Outputs` index 101. 

Then during the challenge window, the verifier notices something is wrong with `l2Outputs` with index 101. The verifiers sees that there is totally invalid data (`OutputRoot`). So, the `Challenger` deletes the `l2Outputs` with index 101 by calling the function `deleteL2Outputs`:
https://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/L1/L2OutputOracle.sol#L128

Please note that Alice's withdrawal transaction was included in block 13100 as well as 13200. Block 13100 was part of `l2Outputs` with index 100 which has valid data (so it is not going to be challenged). But block 13200 was part of `l2Outputs` with index 101 which is challenged and deleted. 

Now, Alice's withdrawal transaction is only included in `l2Outputs` with index 100 (since `l2Outputs` with index 101 is deleted), but it was proven with `l2Outputs` with index 101.

Later, new `l2Outputs` will be proposed by honest proposer, and the proposer is not going to include Alice's withdrawal transaction in `l2Outputs`  with index 101, 102, or anything after. Because, her transaction is already in the valid `l2Outputs` wiht index 100.

Then, Alice decides to finalize her withdrawal on L1, and she calls the function `finalizeWithdrawalTransaction`:
https://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/L1/OptimismPortal.sol#L243

But it will be reverted, because the `l2Outputs` with index 101 (that includes Alice's transaction) now has different `outputRoot`:
https://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/L1/OptimismPortal.sol#L291

So, Alice decides to prove her transaction by calling the function `proveWithdrawalTransaction`. But it reverts also:
- First: her transaction has already a non-zero timestamp (it was once proved by Bob with fake data).
- Second: her transaction is included in `l2Outputs` with index 100 while the mapping `provenWithdrawals[Alice's withdrawalHash] = 101`.
https://github.com/sherlock-audit/2023-01-optimism/blob/main/optimism/packages/contracts-bedrock/contracts/L1/OptimismPortal.sol#L196

The attack summary is:
1. Propose a valid `l2Outputs` with index 100 including the Alice's withdrawal transaction
2. Propose an invalid `l2Outputs` with index 101 including the Alice's withdrawal transaction
3. Proving the Alice's withdrawal transaction with `l2Outputs` with index 101

The solution is that the `Challenger` deletes both `l2Outputs` with indices 100 and 101, and insert the Alice's withdrawal transaction into the `l2Outputs` with index 101. 

But, this solution does not work always. Because, if Bob proposes an invalid `l2Outputs` with index 101 including all the old unproven withdrawal transactions (for example the unproven withdrawal transactions in `l2Outputs` with index 20, 21, 22, ...), and immediately proves them with `l2Outputs` with index 101, all those transactions can not be finalized. So, the `Challenger` must delete all these `l2Outputs` with index from 20 to 101.

## Impact
This can result in deleting a lot of `l2Outputs` that can have large impact on the protocol and user's experience. Or, it may result in prevent of finalizing the withdrawals.
## Code Snippet

## Tool used

Manual Review

## Recommendation
It may make sense allowing to re-prove the withdrawal transactions by the related authority (`Challenger` or the next honest `proposer`). So, if this scenario happens, the related authority can re-prove the withdrawal transaction, even though the `l2Outputs` index and `outputRoot` are both different from what included in the mapping `provenWithdrawals`.